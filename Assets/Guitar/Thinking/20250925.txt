SkillRunner 개혁 필요 - 역할은 대상 식별/앵커 생성과 Cast 둘 뿐
FollowUp은 어떻게 하나요? ISkillMechanic에서 ISkillParams의 FollowUp을 실행하도록 한다
즉 기술이 기술을 콜백하는 구조, 어차피 SkillRunner로 실행되는 것은 궁극적으로 Mechanism이니까
다시 말해 콜백을 SkillRunner에서 실행하면 안 된다, Mechanism이 FollowUp을 callback해야 함
우리의 구조 또한 그에 걸맞게 되어있는데, FollowUp을 가지는 것은 ISkillParams이다
Mechanism이 Params를 기반으로 실행하는 것이므로 FollowUp도 실제 Mechanism에서 실행 중점
SkillRunner는 예외를 하나도 갖지 않는다; 그냥 자기 역할만 한다(Switch Skill을 위해 주문서 선택을 시도하는 등은 무의미)
Switch Skill에 대해 조금 더 언급하자면, Switch Skill 자체의 역할은 그냥 조건에 맞게 Switch하는 것에 불과하다
Switch Skill이라는 이름에 걸맞게 본문 자체는 그냥 Switch 역할이고, 실제 기술의 사용은 FollowUp으로 하는 것
그렇기에 예외를 둘 필요가 전혀 없다, Switch를 본문에서 실행하고 FollowUp을 callback하면 되거든
그런데 대상/비대상이 혼재할 경우에는 어떻게 하는가? FollowUp을 CoCast로 이으면 된다
왜냐면 대상/비대상 판정은 CoCast에서 하고 있거든


FollowUp의 구조?
FollowUp을 어떻게 SkillRunner로 전달하겠는가?
그걸 명확히 하기 위해서 각 Component의 역할을 알 필요가 있다
SkillRunner: 기술을 받아 실행하는 역할
SkillMechanism: 각 기술의 공통 로직
SkillParams: 기술의 데이터를 넣어두는 역할
여기서 FollowUp은 SkillParams에 들어있는데, SkillRunner가 SkillMechanism의 Cast를 실행하고 SkillMechanism이 SkillParams에 맞춰 기술의 효과를 사용하는 구조이다
즉 SkillParams를 읽는 SkillMechanism이 FollowUp을 예약하도록 만들어야 한다
하지만 너무 귀찮지 않은가? 어떻게 타입 하나 새로 만들 때마다 FollowUp 예약을 시키는가?
여기서 우리는 Abstract class를 사용하면 된다
Abstract class의 최대 장점은 공통 로직이 필요한 경우 더없이 손쉽게 그 공통 로직을 사용할 수 있다는 점이다
다만 아무리 Abstract라고 해도 결국 class 상속이기에 부모를 수정하면 자식에게도 큰 영향이 가는 문제점이 있다
하지만 우리는 이미 SkillMechanismBase라는 Abstract class가 있고, 여기에 FollowUp 예약을 시키도록 만들면 실제 문제가 없다
더불어 FollowUp 예약은 어떤 기술이 되었든 동일해야 한다, 다음 기술에 또 다른 대상이 필요하면 SkillRunner가 따로 가져올 것이다


이쯤 해서 기술 재정리
첨언하자면, 대상을 지정할 수 있는("Targeted:"로 표시) 모든 기술은 앵커를 대상으로 삼아 비대상 기술로 만들 수 있다
Melee(정면 부채꼴 방향을 공격, deg가 360이면 원형 공격도 가능)
Projectile(Targeted: 투사체를 발사)
ㄴ지금은 ProjectileMovement 코드가 따로 있는데 이걸 Mechanism에 통합하는 것도(Projectile의 Prefab이 Movement를 가져가게 하는 등) 괜찮을 듯
  ㄴ사실 지금도 projectile에 AddComponent를 적용하여 통합하고는 있지만 의존도가 조금 있는 것 같음, 근데 이대로도 괜찮다면 그냥 남기고
ㄴ벽은 통과 못 하는 게 좋을 듯, 개나소나 벽을 넘기면 밸런스 잡기가 어려워지는 느낌
Hitscan(Targeted: 대상을 즉시 공격, 이 기술은 비대상으로 사용하지 않게 조심한다)
ㄴ대상에게 레이저 쏘는 기술도 Hitscan, 다만 시각 효과만 좀 달리하면 된다
Area(Targeted: 특정 지점으로부터 일정 범위를 공격, AreaType을 통해 사각형/원형 등을 구분한다)
ㄴ duration을 지정하여(기본값은 0) 장판 기술도 만들 수 있을 듯
Dash(Targeted: 돌진, 적을 관통할 수도 있다)
ㄴ기본적으로 Move와 동일한 구조를 갖기 때문에 벽은 넘을 수가 없다
Teleport(Targeted: 순간이동, 경로 상의 적을 공격하게 만들 수도 있다)
ㄴTeleport는 필드에서 사라진다-대상 위치로 이동한다-나타난다 순서
  ㄴ그렇기에 "필드의 대상을 추적하는" 기술을 피할 수 있음(필드에서 사라지는 처리가 있으므로), 이것은 의도된 사항
    ㄴ추가로 Teleport는 비대상으로 사용하는 일이 가능한 한 없었으면 좋겠다, 메커니즘 자체가 너무 강해서 적어도 상대가 대응할 여지를 줘야 함
Effect(Targeted: 효과를 입힌다, Effect를 사용하기 위해 OnHit Target을 얻는 로직이 필요할 듯)
ㄴStack도 Effect로 사용한다? 이거 괜찮은 방법인 듯
  ㄴ ApplyStack을 따로 만들고 ApplyEffect에서 여기로 분기를 이어준다, 외부에는 ApplyEffect만 노출
Gain(Targeted: 체력/마나를 회복하거나 보호막/특수 보호막을 획득)
ㄴ공격력/방어력/AP(Armor Penetration)/DR(Damage Reduction) 등은 상대 때문에 시시각각 변하는 Stat이 아니라 Effects로 이을 수 있다(로컬에서 즉시 적용하고 relay에 전달 가능)
  ㄴ그런데 체력, 마나, 보호막, 특수 보호막은 변동이 잦은 Stat들이므로 Effect와 다른 기술로 만드는 게 낫다고 판단(안 나으면 그냥 Effect로 통합할 수도 있음)
Switch(위에서 계속 말한 Switch Skill, SwitchType을 재사용(Reuse)/시전 시(Oncast)/강화(Upgrade)로 만들면?)
ㄴReuse: 일정 시간 안에 발동해서 추가 효과를 사용하는 것
ㄴOncast: 기술 발동 후에 다른 기술로 바뀌는 것
ㄴUpgrade: 특정 조건 만족 시에 강화된 기술로 바꾸는 것
   ㄴUpgrade는 Passive에 활용하기 좋은 Type, 조건은 전부 Stack으로 판정하기
     ㄴ 그러면 N초마다 강화는 어떻게 하느냐? N초마다 Stack을 새로 생성해주면 된다
Delay(FollowUp(Switch처럼 이게 실제 발동하는 기술)의 사용 타이밍을 조절하거나 추가 효과(피해량 증가 등)를 얻을 수 있음)
ㄴDelay 중에 적용해야 할 게 있다면 OnWait에서 돌리면 어떨까(+10/01)
ㄴDelay는 자동으로 지연이 주어지거나 수동으로 임의의 지연을 가할 수도(Hold) 있음
  ㄴbool hold의 값을 바꾸는 것으로 Delay인지 Hold인지 정할 수 있음
    ㄴDelay Skill 자체는 딱히 어떤 효과를 갖지 않으며 단지 Delay 조절을 용이하게 하고 보상(Stack 등)을 확실하게 얻을 수 있게 하기(+09/30)
ㄴ반격도 Delay로 사용하는데 이 경우 Gain FollowUp Hold FollowUp... 의 순서로 사용한다, 이에 따라 Hold의 FollowUp cast 시에 추가 조건을 만드는 게 좋을 듯

!!!!!Added(10/01)
Channel(Targeted: Delay/Hold와 다르게 누르고 있는 동안에 FollowUp의 효과를 유지)
ㄴFollowUp을 주기적으로 호출하게 만들기
  ㄴ더 나은 방법이 있을지도 모르겠지만 일단은 이 방법이 떠올랐음
Summon(Targeted: GameObject를 특정 위치에 소환)
ㄴ뭔가를 대상으로 GameObject를 소환하게 만들 거라면 소환 시에 Depenetration을 잊지 말기
  ㄴ소환되는 GameObject는 Prefab을 이용하면 좋을지도?
Toggle(특정 효과의 사용 여부를 전환)
ㄴTargeted Toggle은 딱히?

?????Can be added(10/01)
Mode(Switch-Stack보다 더 큰 범위를 변경해야 할 때)
ㄴSwitch-Stack은 기껏해야 기술만 바뀌는 정도라 그 이상으로 넘어가려면 필요할 수 있음
Command(소환수를 제어하는 데 사용)
ㄴ움직이게 만들거나, 특정 대상을 공격하게 시키는 등으로 활용할 수 있겠음
  ㄴ단 하나의 소환수에 서로 다른 여러 가지 명령을 내리는 것은 딱히 좋은 아이디어 같지 않음


무브셋을 쭉 훑어봤는데 흘리기가 조금 문제인 것 같은
원래 3D 게임으로 만들려던 거라서 흘리기가 유효했는데(구현 난이도는 별개로 치고) 지금은 흘리기를 잘 만드는 게 어려워 보인다
아예 삭제하는 게 방법일 수도? 솔직히 반격도 잘 안 쓰이는 마당에 흘리기는 더 사용처가 없음
더군다나 흘리기의 경우에는 범용성이 너무 떨어짐, 무적이야 Effects에 Invincible을 추가한다고 하는데 Invincible은 IVulnerable의 TakeDamage를 무효로 할 뿐
그런데 흘리기는 말 그대로 내가 받는 공격을 무효로 해야 하기 때문에 이걸 구현하는 방법은 대표적으로 두 가지
1: 피격 대상으로 선정되지 않는다(아예 Collider를 잠시 무효로 하기?)
2: 상대의 공격이 닿는 즉시 상대 공격을 종료시킨다
어느 쪽이든 딱히 만들고 싶은 효과라는 생각이 들지 않음
그러면 지금 있는 흘리기는 어떻게 하나? 그건 알아서 잘 조정해야지