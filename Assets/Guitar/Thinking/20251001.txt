Determinism을 확보하기 위해 Priority level을 고안한다
여러 가지 효과가 동시에 발동할 경우 이걸 적절히 resolve해야 하기 때문이다
여기서 중요한 건 Priority가 상대 기술을 씹어주지는 않는다는 것
한 틱에 서로 다른 두 공격의 판정이 맞붙었을 때 어느 쪽이 먼저 맞은 것으로 판정할 것이냐를 확정하는 단계이다
즉 아무도 상대의 공격으로 죽지 않으면 실질적으로 동시 히트(순차 판정이긴 하나 그 순차 판정이 해당 프레임에 종료되므로)
실질적으로 Priority가 도움이 되는 경우는 양쪽이 한대 맞고 죽는 경우
예를 들어 P1은 궁으로 막타를 치고 P2가 평타로 막타를 치려 한다
이 경우라면 무조건 P2가 진다, 궁극기의 Priority는 최소 30000인데 평타의 Priority는 13120을 넘을 수 없음(120 = 홀드 최대 시간인 2초의 딜레이프레임)
(10/10) 이러면 궁을 빨리 돌리는 캐릭터가 유리한 경향을 보일 수 있다, 궁이 주력인 경우에는 킬각을 잡기 조금 어렵게 만들자
(10/10) 또 지속 피해는 타입 Priority가 무조건 1000이며(Effect) 슬롯 Priority와 딜레이 Priority는 그걸 유발한 기술의 데이터를 따른다, 지딜은 계속 TakeDamage를 호출하니 어찌 보면 당연한 것

현재 고려하고 있는 방법은 아래 규칙 중 몇 가지를 따라(다 적용할 수도 있고) Priority level을 생성하도록 하여 Determinism의 파괴를 막는 것
추가로 규칙 자체의 Priority도 고려할 텐데 1번이 가장 크고 아래로 갈수록 Priority를 적게 주지 않을까 싶다

1: 기술의 슬롯에 따른 Priority (Priority += weight * 10000)
궁극기(RMB, weight 3) > 일반 기술(Space & Shift & 강화/대체된 LMB, weight 2) > 일반 공격(LMB, weight 1)

2: 기술의 타입에 따른 Priority(Priority += weight * 1000)
직접 공격 기술(Melee & Projectile & Hitscan & Area, weight 3) > 기동형 공격 기술(Dash & Teleport, weight 2) > 기타 기술(Effect & Gain, weight 1)
Channel, Toggle, Switch, Delay, Summon, Mode, Command는 기술 본문 자체에 딱히 효과가 없으므로 고려하지 않는다
Melee와 Melee가 맞닿을 경우, 시전 순서에 상관이 없다면 동시 피격 판정을 낸다
하지만 Melee와 Stun Effect가 맞닿을 경우에는 무조건 Melee가 먼저 발동, Stun은 Melee의 발동 후에 적용한다
Melee FollowUp Stun일 경우 어떡하나? 이 경우 Melee 발동 후에 Stun이 적용되는 것이므로 동시 발동 시에는 상대도 이미 공격한 후
즉 동시 타격으로는 상대 때문에 공격이 끊길 일이 없어야 한다, 그게 공격자 우선이니까 음
어차피 동타 나오는 것도 꽤 희귀한 일인데 Deterministic game이라서 동타를 노리는 사람들이 나올까 봐 일부러 이처럼 구조화

3: 기술의 시전 시 딜레이에 따른 Priority(Priority += DelayFrame(1초에 60))
동일한 배치와 동일한 타입의 기술이 서로 다른 시전 시 딜레이를 가질 경우에는 딜레이가 더 큰 쪽을 우선으로 한다
맞추기 어려운 만큼 보상을 준다는 느낌?
이걸로 타입 Priority를 1단계 이기려면 16.666초 딜레이가 필요하며 슬롯 Priority를 1단계 이기려면 166.666초 딜레이가 필요하다
사실 17초 동안 딜레이만 걸려있으면 그냥 그 사이에 풀콤보로 죽고, 그냥 동일 배치에 동일 타입 기술이 충돌할 때 약간의 우선권을 보장하는 정도
Delay Skill이 아닌 기술은 임의로 시전 시 딜레이를 설정할 수가 없어서 그냥 정해진 대로 따라야 하고 Delay Skill은 진짜로 홀드만 하다가는 맞아 죽는다
거기다 Delay Skill의 limit를 설정하면(2초 정도가 좋지 않을까 싶음) 타입 Priority도 못 이긴다, 그냥 "웬만해서는 동시타 내지 마라" 라는 선언
아니면 그냥 Delay 무한으로 땡길 수 있게 한다? 만약 평타에 Hold를 줄 수 있다면 333.333초 이상 홀드해서 궁을 Priority로 이길 수 있음
(10/10) 이러면 재밌기야 하겠지만 딱히 그렇게 해줘야 할 이유가 없음, Priority 때문이 아니고 무한 홀드 처리 때문에

4: FollowUp의 수에 따른 Priority(이건 고려하기 어려워서 안 쓸 것 같다, 위의 규칙들을 따라도 웬만큼 Priority가 구분되기도 하고)
ㄴ결국 제거해도 무방한 것 같다, 동시 히트를 이렇게까지 까다롭게 다룰 필요 없음
  ㄴ거기다 FollowUp도 일반 Cast처럼 다룬다면서? 그러면 이거 안 되지

이제 1, 2, 3에 따라 Priority level을 적용한다 가정하고 시뮬레이션을 해보자

case 1: P1 Melee FollowUp none(타입 Priority 3000) vs. P2 Melee FollowUp Effect(Stun)(타입 Priority 3000)
  슬롯이 같다(슬롯 Priority 동일):
    시전 시 딜레이가 같다(딜레이 Priority 동일):
      P1과 P2는 Priority level이 같아 동시에 피해를 받고 P1은 이후 Stun을 받는다
    시전 시 딜레이가 다르다:
      P2의 딜레이가 더 길었을 경우 P2의 Priority level이 상위; 무조건 P1이 먼저 공격한다
      즉 P1이 죽을 피였다면 그냥 죽고 게임 끝, 아니면 P1이 P2를 공격하고 FollowUp Stun을 받는다(FollowUp은 동시 타이밍 처리가 아님)
  슬롯이 다르다:
    상위 배치로 사용한 쪽이 무조건 먼저 공격한다
    즉 상대가 죽을 피였다면 상대를 죽이고 게임을 이긴다

case 2: P1 Melee FollowUp Effect(Slow)(타입 Priority 3000) vs. P2 Area FollowUp Effect(Slow)(타입 Priority 3000)
  슬롯이 다르다:
    상위 슬롯으로 사용한 쪽이 무조건 먼저 공격한다
  슬롯이 같다(슬롯 Priority 동일):
    시전 시 딜레이가 길었던 쪽이 먼저 공격한다

case 3: P1 Hitscan FollowUp none(타입 Priority 3000) vs. P2 Gain(Health) FollowUp none(타입 Priority 1000)
  슬롯이 다르다:
    상위 슬롯으로 사용한 쪽의 효과가 먼저 발동한다, 가령 P2의 기술이 궁극기라면 체력을 회복한 후 Hitscan 피해를 받는다
  슬롯이 같다:
    무조건 Hitscan을 먼저 맞고 체력을 회복한다, 체력 회복은 이럴 때 손해가 없지만 보호막/특수 보호막은 약간 손해를 본다(맞고 보호막 얻는 거니까)

case 4: P1 RMB Melee(배치 + 타입 Priority 33000) vs. P2 RMB Melee(배치 + 타입 Priority 33000)
  이때는 무조건 딜레이 따라서 판정이고 딜레이도 똑같다면 동시 히트

동시 히트는 어떻게 하는가:
동시 히트가 발생하는 경우 일반 TakeDamage를 각각 호출하는 대신 해당 틱에 히트하는 모든 대상을 모아서 TieBreaker(params IVulnerable[] hitters)에 전달한다
TieBreaker는 모든 대상에게 각기 피해 처리를 하고 Die()의 판정은 TieBreaker 종료 시에 한다
사실 완전한 동시 히트는 엄청 어려운 게, 아무튼 TieBreaker를 사용한다고 해도 결국은 순차 처리가 될 수밖에 없다
이건 프로그램 자체의 특징, 멀티스레딩으로 해결할 수는 있으나 동시 히트 하나 처리하려고 굳이 Task 돌릴 필요가 있나 싶음
거기다 스레드 돌리는 것도 타이밍을 아주 정밀하게 잡지 않으면 어차피 완전 동시가 아님
즉 동시 히트로 무승부를 내기 위해서는 피해 처리 후의 후속 판정을 미루는 것이 최적이라고 생각한다
참고: TieBreaker의 parameter는 IVulnerable 타입일 필요는 없지만 대략적인 설명을 위해 이렇게 서술하였다

추가로 현재 코드의 구조를 조금 점검할 필요가 있을 것 같음
지금 코드는 대충 완성된 것 같은데 분석이 안 돼서 건드리기 두려운 부분
이번 연휴를 기해서 코드를 분석해놓고 돌아오는 평일에 다시 개발을 시작하는 것이 어떤지?
특히 이번에는 Codex를 사용했는데 얘는 훨씬 광범위하고 많은 코드를 내놓는지라(아예 github pull request를 내올 정도니까)
이 추가되거나 수정된 코드를 잘 살피지 않으면 결국 구조를 제대로 잡을 수 없을 것
지금 우리는 불확실성 때문에 코드를 확장할 수 없는 것이지만 모든 불확실성의 근원은 해결 가능함, 그때가 언제인지 모를 뿐임
하지만 이미 어느 정도 가닥은 잡혔음, 로컬이 맡던 부분을 고칠 필요가 없다는 게 다행
이 덕에 우리는 이제 SkillRunner 및 기타 Base의 수정이 거의 완료되었고 이제 또 기능을 추가할 때가 다가오고 있음
근데 Base 자체에 아직 잡히지 않은 버그도 있고 기능 추가에 있어 기존의 Base와 통합해야 하니까 분석이 필요할 뿐이지